# Дерево отрезков

## Общая концепция

Дерево отрезков - это структура данных, позволяющая эффективно находить сумму и менять данные в элементах отрезка.
Дерево отрезков используется для учета предоставленной ликвидности. 
Каждый депозит представлен в виде отдельного элемента "листа" на дереве отрезков. 
Листы - самые удаленные элементы в дереве отрезков. 
Два листа (левый и правый) объединяются в один узел предок. Два узла (левый и правый) объединяются в узел предка и так далее до единого корня всего дерева отрезков.
Корневой узел дерева отрезков представляет собой наиболее актуальное значение суммы нижних элементов (листьев). 
Корень не имеет предков, а листья не имееют потомков.

В задаче учета ликвидности корневой узел содержит наиболее актуальную ликвидность.

## Организация дерева отрезков
Все узлы дерева отрезков записаны как элементы массива. 
Для хранения данных в элементах **K**, необходим массив размерностью **K*2+1**. 
Элемент номер **0** не используется, корневой узел имеет номер **1**, первый лист имеет номер **K**
Потомки корневого узла: **2** - левый потомок **3** - правый потомок

Навигация внутри дерева отрезков производится через соотношение номера узлов, левый потомок узла **X** имеет номер **2*X** , правый потомок имеет номер **2*X+1**.

*Пример дерева отрезков для хранения 4-х элементов*
```shell
+--------------------------------------------+
|                  1 (top node)              |
+------------------------+-------------------+
|             2          |         3         |
+-------------+----------+---------+---------+
|   4 (leaf)  |     5    |    6    |    7    |
+-------------+----------+---------+---------+
```

## Добавление ликвидности
При каждом добавлении ликвидности производится:
1. инициализацией следующего по порядку листа (следующего не использованного).
2. добавление суммы в предка листа
3. добавления суммы в вышестоящего предка и так далее до корня дерева отрезков, рекурсивно.
   
За добавление ликвидности в контракте отвечает метод **``` function nodeAddLiquidity(uint128 amount) public```**

Таким образом после добавления, будет добавлена сумма **```amount```** в лист и во все ноды-предки, включая корневой узел.
Инициализация листа может быть сделана только один раз. 
В дальнейшем сумма в листе может только меняться в результате распределения прибыли/убытка или вывода ликвидности (полного) из листа.

*Пример состояния дерева отрезков после добавления ликвидности, обновились узлы **4**, **5**, **2**, **1***

```shell
nodeAddLiquidity(100$)
+--------------------------------------------+
|                    1 (100$)                |
+------------------------+-------------------+
|         2 (100$)       |         3         |
+-------------+----------+---------+---------+
|   4 (100$)  |     5    |    6    |    7    |
+-------------+----------+---------+---------+
     +100$

nodeAddLiquidity(200$)
+--------------------------------------------+
|                    1 (300$)                |
+------------------------+-------------------+
|         2 (300$)       |         3         |
+-------------+----------+---------+---------+
|   4 (100$)  | 5 (200$) |    6    |    7    |
+-------------+----------+---------+---------+
                  +200$
```

## Взятие ликвидности для обеспечения "игры" в протоколе
Для обеспечения "игры", можно "брать" ликвидность, согласно текущего состояния дерева отрезков: текущей суммы в корневом узле **1** и для дальнейшего справделивого распределения необходимо "запомнить" последний актуальный лист. 
Взятие ликвидности происходит методом **```function remove(uint128 amount) public```**. 
Метод **```remove```** использует "ленивое обновление" нижестоящих узлов, таким образом, что если обновляемый список листов полностью лежит в родительском узле, то обновляется только данный родительский узел и дальнейшие изменения дочерних узлов не производятся и откладывается.

*Пример состояния дерева отрезков после взятия ликвидности для "игры" (10$), обновились узлы **1** и **2** , т.к. изменения касаются только списка листов [4, 5], и весь список входит в узел **2**, нужно обновить только сумму узла **1** и **2***

```shell
remove(10$)
+--------------------------------------------+
|                    1 (290$)                |
+------------------------+-------------------+
|         2 (290$)       |         3         |
+-------------+----------+---------+---------+
|   4 (100$)  | 5 (200$) |    6    |    7    |
+-------------+----------+---------+---------+
```

*после этого, например, произошло добавление ликвидности (в следующий лист **6**), обновились узлы **6**, **3**, **1***

```shell
nodeAddLiquidity(300$)
+--------------------------------------------+
|                    1 (590$)                |
+------------------------+-------------------+
|         2 (290$)       |    3 (300$)       |
+-------------+----------+---------+---------+
|   4 (100$)  | 5 (200$) | 6 (300$)|    7    |
+-------------+----------+---------+---------+
                            +300$
```

## Возвращение ликвидности 
Происходит с указанием суммы возвращения и номера листа, указывающего диапазон распределения возвращенной суммы от первого элемента до актуального на момент "взятия ликвидности".
Производится методом **```function addLimit(uint128 amount, uint48 leaf) public```**

*В примере обновляются узлы **1**, **2**. Данные в **4**, **5** не меняются, т.к. **4**, **5** входят в узел **2** и ленивое обновление остановилось на **2***

```shell
addLimit(13$, 5)
+13$  [4, 5]
+--------------------------------------------+
|                    1 (603$)                |
+------------------------+-------------------+
|         2 (303$)       |    3 (300$)       |
+-------------+----------+---------+---------+
|   4 (100$)  | 5 (200$) | 6 (300$)|    7    |
+-------------+----------+---------+---------+
```

## Вывод ликвидности
Производится методом **```function nodeWithdrawLiquidity(uint48 leaf) public```**
Для вывода сначала производится: 
1. поиск "самого обновленного предка" от листа
2. обновление (актуализация) данных по сумме в листе от "самого обновленного предка", таким образом в листе обновится сумма
3. затем выводится полностью ликвидность из листа, с обновлением всех узлов-предков от листа до корня.

```shell
nodeWithdrawLiquidity(4) 
+--------------------------------------------+
|                     1 (502$)               |
+------------------------+-------------------+
|         2 (202$)       |    3 (300$)       |
+-------------+----------+---------+---------+
|    4 (0$)   | 5 (200$) | 6 (300$)|    7    |
+-------------+----------+---------+---------+
     -101$


nodeWithdrawLiquidity(5) 
+--------------------------------------------+
|                     1 (300$)               |
+------------------------+-------------------+
|           2 (0$)       |    3 (300$)       |
+-------------+----------+---------+---------+
|    4 (0$)   |  5 (0$)  | 6 (300$)|    7    |
+-------------+----------+---------+---------+
                  -202$
```