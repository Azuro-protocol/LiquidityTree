# Дерево отрезков

## Общая концепция

Дерево отрезков - это структура данных, позволяющая эффективно находить сумму и менять данные в элементах отрезка.
Дерево отрезков используется для учета предоставленной ликвидности. 
Каждый депозит представлен в виде отдельного элемента "листа" на дереве отрезков. 
Листы - самые удаленные элементы в дереве отрезков. 
Два листа (левый и правый) объединяются в один узел предок. Два узла (левый и правый) объединяются в узел предка и так далее до единого корня всего дерева отрезков.
Корневой узел дерева отрезков представляет собой наиболее актуальное значение суммы нижних элементов (листьев). 
Корень не имеет предков, а листья не имееют потомков.

В задаче учета ликвидности корневой узел содержит наиболее актуальную ликвидность.

## Организация дерева отрезков
Все узлы дерева отрезков записаны как элементы массива. 
Для хранения данных в элементах __K__, необходим массив размерностью __K*2+1__. 
Элемент номер __0__ не используется, корневой узел имеет номер __1__, первый лист имеет номер __K__
Потомки корневого узла: __2__ - левый потомок __3__ - правый потомок

Навигация внутри дерева отрезков производится через соотношение номера узлов, левый потомок узла __X__ имеет номер __2*X__ , правый потомок имеет номер __2*X+1__.

Пример дерева отрезков для хранения 4-х элементов
```shell
+--------------------------------------------+
|                  1 (top node)              |
+------------------------+-------------------+
|             2          |         3         |
+-------------+----------+---------+---------+
|   4 (leaf)  |     5    |    6    |    7    |
+-------------+----------+---------+---------+
```

## Добавление ликвидности
При каждом добавлении ликвидности производится:
1) инициализацией следующего по порядку листа (следующего не использованного).
2) добавление суммы в предка листа
3) добавления суммы в вышестоящего предка и так далее до корня дерева отрезков, рекурсивно.
   
За добавление ликвидности в контракте отвечает метод __``` function nodeAddLiquidity(uint128 amount) public```__

Таким образом после добавления, будет добавлена сумма __```amount```__ в лист и во все ноды-предки, включая корневой узел.
Инициализация листа может быть сделана только один раз. 
В дальнейшем сумма в листе может только меняться в результате распределения прибыли/убытка или вывода ликвидности (полного) из листа.

Пример состояния дерева отрезков после добавления ликвидности, обновились узлы __4__, __5__, __2__, __1__

```shell
nodeAddLiquidity(100$)
+--------------------------------------------+
|                    1 (100$)                |
+------------------------+-------------------+
|         2 (100$)       |         3         |
+-------------+----------+---------+---------+
|   4 (100$)  |     5    |    6    |    7    |
+-------------+----------+---------+---------+
     +100$

nodeAddLiquidity(100$)
+--------------------------------------------+
|                    1 (300$)                |
+------------------------+-------------------+
|         2 (300$)       |         3         |
+-------------+----------+---------+---------+
|   4 (100$)  | 5 (200$) |    6    |    7    |
+-------------+----------+---------+---------+
                  +200$
```

## Взятие ликвидности для обеспечения "игры" в протоколе
Для обеспечения "игры", можно "брать" ликвидность, согласно текущего состояния дерева отрезков: текущей суммы в корневом узле __1__ и для дальнейшего справделивого распределения необходимо "запомнить" последний актуальный лист. 
Взятие ликвидности происходит методом __```function remove(uint128 amount) public```__. 
Метод __```remove```__ использует "ленивое обновление" нижестоящих узлов, таким образом, что если обновляемый список листов полностью лежит в родительском узле, то обновляется только данный родительский узел и дальнейшие изменения дочерних узлов не производятся и откладывается.

Пример состояния дерева отрезков после взятия ликвидности для "игры" (10$), обновились узлы __1__ и __2__ , т.к. изменения касаются только списка листов [4, 5], и весь список входит в узел __2__, нужно обновить только сумму узла __1__ и __2__

```shell
remove(10$)
+--------------------------------------------+
|                    1 (290$)                |
+------------------------+-------------------+
|         2 (290$)       |         3         |
+-------------+----------+---------+---------+
|   4 (100$)  | 5 (200$) |    6    |    7    |
+-------------+----------+---------+---------+
```

после этого, например, произошло добавление ликвидности (в следующий лист __6__), обновились узлы __6__, __3__, __1__

```shell
nodeAddLiquidity(200$)
+--------------------------------------------+
|                    1 (590$)                |
+------------------------+-------------------+
|         2 (290$)       |    3 (300$)       |
+-------------+----------+---------+---------+
|   4 (100$)  | 5 (200$) | 6 (300$)|    7    |
+-------------+----------+---------+---------+
                            +300$
```

## Возвращение ликвидности 
Происходит с указанием суммы возвращения и номера листа, указывающего диапазон распределения возвращенной суммы от первого элемента до актуального на момент "взятия ликвидности".
Производится методом __```function addLimit(uint128 amount, uint48 leaf) public```__

В примере обновляются узлы __1__, __2__. Данные в __4__, __5__ не меняются, т.к. __4__, __5__ входят в узел __2__ и ленивое обновление остановилось на __2__

```shell
addLimit(13$, 5)
+15$  [4, 5]
+--------------------------------------------+
|                    1 (603$)                |
+------------------------+-------------------+
|         2 (303$)       |    3 (300$)       |
+-------------+----------+---------+---------+
|   4 (100$)  | 5 (200$) | 6 (300$)|    7    |
+-------------+----------+---------+---------+
```

## Вывод ликвидности
Производится методом __```function nodeWithdrawLiquidity(uint48 leaf) public```__
Для вывода сначала производится: 
1) поиск "самого обновленного предка" от листа
2) обновление (актуализация) данных по сумме в листе от "самого обновленного предка", таким образом в листе обновится сумма
3) затем выводится полностью ликвидность из листа, с обновлением всех узлов-предков от листа до корня.

```shell
nodeWithdrawLiquidity(4) 
+--------------------------------------------+
|                     1 (502$)               |
+------------------------+-------------------+
|         2 (202$)       |    3 (300$)       |
+-------------+----------+---------+---------+
|    4 (0$)   | 5 (200$) | 6 (300$)|    7    |
+-------------+----------+---------+---------+
     -101$


nodeWithdrawLiquidity(5) 
+--------------------------------------------+
|                     1 (300$)               |
+------------------------+-------------------+
|           2 (0$)       |    3 (300$)       |
+-------------+----------+---------+---------+
|    4 (0$)   |  5 (0$)  | 6 (300$)|    7    |
+-------------+----------+---------+---------+
                  -202$
```